"""Client stub code generator for aduib_rpc.

Generates Python client classes from Proto service definitions.
"""
from __future__ import annotations

from typing import Final

__all__ = ["generate_client_code", "ClientGenerator"]

# Client generation template
_CLIENT_TEMPLATE: Final = '''"""Autogenerated client for {service_name}.

Generated from: {proto_file}
DO NOT EDIT - This file was generated by aduib-codegen.
"""

from __future__ import annotations

import asyncio
from typing import Any

from aduib_rpc.client import RpcClient
from aduib_rpc.exceptions import RpcException


class {service_name}Client:
    """Client for {service_name} service.

    Usage:
        client = {service_name}Client("localhost:8080")
        response = await client.method_name(request)
    """

    def __init__(
        self,
        address: str,
        *,
        timeout_ms: int = 30000,
        protocol: str = "http",
    ) -> None:
        """Initialize the client.

        Args:
            address: Server address (host:port).
            timeout_ms: Request timeout in milliseconds.
            protocol: Transport protocol.
        """
        self._client = RpcClient(
            address=address,
            timeout_ms=timeout_ms,
            protocol=protocol,
        )

    async def call(
        self,
        method: str,
        request: Any | None = None,
        **kwargs: Any,
    ) -> Any:
        """Call an RPC method.

        Args:
            method: Method name.
            request: Request data.
            **kwargs: Additional request parameters.

        Returns:
            Response data.
        """
        return await self._client.call(
            service="{service_name}",
            method=method,
            data=request or kwargs,
        )
{method_stubs}

    async def close(self) -> None:
        """Close the client connection."""
        await self._client.close()

    async def __aenter__(self) -> "{service_name}Client":
        """Async context manager entry."""
        return self

    async def __aexit__(self, *args: Any) -> None:
        """Async context manager exit."""
        await self.close()
'''


_METHOD_TEMPLATE: Final = '''
    async def {method_name}(
        self,
        request: {request_type} | None = None,
        **kwargs: Any,
    ) -> {response_type}:
        """Call {method_name} method.

        Args:
            request: Request data of type {request_type}.
            **kwargs: Alternative request fields.

        Returns:
            Response of type {response_type}.
        """
        return await self.call(
            "{method_name}",
            request,
            **kwargs,
        )
'''


def generate_client_code(
    service_name: str,
    methods: list[dict],
    proto_file: str = "",
) -> str:
    """Generate client code for a service.

    Args:
        service_name: Name of the service.
        methods: List of method dictionaries with 'name', 'request_type', 'response_type'.
        proto_file: Original proto file path for documentation.

    Returns:
        Generated Python code as string.
    """
    # Generate method stubs
    method_stubs = []
    for method in methods:
        method_stubs.append(_METHOD_TEMPLATE.format(
            method_name=method.get("name", "unknown"),
            request_type=_to_python_type(method.get("request_type", "Any")),
            response_type=_to_python_type(method.get("response_type", "Any")),
        ))

    # Combine all method stubs
    all_method_stubs = "".join(method_stubs)

    return _CLIENT_TEMPLATE.format(
        service_name=service_name,
        proto_file=proto_file or "unknown",
        method_stubs=all_method_stubs,
    )


class ClientGenerator:
    """Client code generator with more configuration options."""

    def __init__(
        self,
        async_client: bool = True,
        with_types: bool = True,
        with_docstrings: bool = True,
    ) -> None:
        """Initialize the generator.

        Args:
            async_client: Generate async client (otherwise sync).
            with_types: Include type hints.
            with_docstrings: Include docstrings.
        """
        self.async_client = async_client
        self.with_types = with_types
        self.with_docstrings = with_docstrings

    def generate(self, service, proto_file: str = "") -> str:
        """Generate client code from a ProtoService.

        Args:
            service: ProtoService instance.
            proto_file: Original proto file path.

        Returns:
            Generated Python code.
        """
        methods = [
            {
                "name": rpc.name,
                "request_type": rpc.request_type,
                "response_type": rpc.response_type,
            }
            for rpc in service.rpcs
        ]

        return generate_client_code(
            service_name=service.name,
            methods=methods,
            proto_file=proto_file,
        )


def _to_python_type(proto_type: str) -> str:
    """Convert Proto type to Python type annotation.

    Args:
        proto_type: Proto type name.

    Returns:
        Python type annotation string.
    """
    # Primitive type mappings
    primitives = {
        "double": "float",
        "float": "float",
        "int32": "int",
        "int64": "int",
        "uint32": "int",
        "uint64": "int",
        "sint32": "int",
        "sint64": "int",
        "fixed32": "int",
        "fixed64": "int",
        "sfixed32": "int",
        "sfixed64": "int",
        "bool": "bool",
        "string": "str",
        "bytes": "bytes",
    }

    if proto_type in primitives:
        return primitives[proto_type]

    # Check for repeated (list)
    if proto_type.startswith("repeated "):
        base_type = proto_type[9:].strip()
        return f"list[{_to_python_type(base_type)}]"

    # Check for map (dict)
    if proto_type.startswith("map<") and proto_type.endswith(">"):
        inner = proto_type[4:-1].strip()
        if "," in inner:
            key_type, value_type = inner.split(",", 1)
            return f"dict[{_to_python_type(key_type.strip())}, {_to_python_type(value_type.strip())}]"

    # Default to Any for message types
    return proto_type
