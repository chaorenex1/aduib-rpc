"""Server interface code generator for aduib_rpc.

Generates Python server base classes from Proto service definitions.
"""
from __future__ import annotations

from typing import Final

__all__ = ["generate_server_code", "ServerGenerator"]

# Server generation template
_SERVER_TEMPLATE: Final = '''"""Autogenerated server implementation for {service_name}.

Generated from: {proto_file}
DO NOT EDIT - This file was generated by aduib-codegen.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Any

from aduib_rpc.server import RpcServer
from aduib_rpc.exceptions import RpcException


class {service_name}Service(ABC):
    """Abstract base class for {service_name} service.

    Implement these methods to create your service:

    ```python
    class My{service_name}Service({service_name}Service):
        async def method_name(self, request: RequestType) -> ResponseType:
            # Your implementation here
            return response
    ```
    """
{method_abstracts}
'''


_METHOD_ABSTRACT_TEMPLATE: Final = '''
    @abstractmethod
    async def {method_name}(
        self,
        request: {request_type} | None = None,
        **kwargs: Any,
    ) -> {response_type}:
        """Handle {method_name} RPC call.

        Args:
            request: Request data of type {request_type}.
            **kwargs: Additional request parameters.

        Returns:
            Response of type {response_type}.

        Raises:
            RpcException: On RPC errors.
        """
        raise NotImplementedError
'''


_IMPL_TEMPLATE: Final = '''"""Autogenerated server implementation for {service_name}.

Generated from: {proto_file}
DO NOT EDIT - This file was generated by aduib-codegen.
"""

from __future__ import annotations

from typing import Any

from {service_lower}_service import {service_name}Service


class {service_name}Impl({service_name}Service):
    """Default implementation of {service_name} service.

    This is a placeholder implementation. Replace the methods
    with your actual business logic.
    """
{method_impls}
'''


_METHOD_IMPL_TEMPLATE: Final = '''
    async def {method_name}(
        self,
        request: {request_type} | None = None,
        **kwargs: Any,
    ) -> {response_type}:
        """Handle {method_name} RPC call."""
        # TODO: Implement {method_name}
        raise NotImplementedError("{method_name} not implemented")
'''


_DECORATOR_TEMPLATE: Final = '''
from aduib_rpc.server.rpc_method import rpc_service

@rpc_service(name="{service_name}")
class {service_name}Impl({service_name}Service):
    """RPC service implementation for {service_name}."""
{method_impls}
'''


def generate_server_code(
    service_name: str,
    methods: list[dict],
    proto_file: str = "",
    generate_impl: bool = False,
) -> str:
    """Generate server code for a service.

    Args:
        service_name: Name of the service.
        methods: List of method dictionaries with 'name', 'request_type', 'response_type'.
        proto_file: Original proto file path for documentation.
        generate_impl: Generate implementation class instead of abstract base.

    Returns:
        Generated Python code as string.
    """
    if generate_impl:
        return _generate_impl_class(service_name, methods, proto_file)

    # Generate abstract methods
    method_abstracts = []
    for method in methods:
        method_abstracts.append(_METHOD_ABSTRACT_TEMPLATE.format(
            method_name=method.get("name", "unknown"),
            request_type=_to_python_type(method.get("request_type", "Any")),
            response_type=_to_python_type(method.get("response_type", "Any")),
        ))

    all_method_abstracts = "".join(method_abstracts)

    return _SERVER_TEMPLATE.format(
        service_name=service_name,
        proto_file=proto_file or "unknown",
        method_abstracts=all_method_abstracts,
    )


def _generate_impl_class(
    service_name: str,
    methods: list[dict],
    proto_file: str,
) -> str:
    """Generate implementation class with stubs.

    Args:
        service_name: Name of the service.
        methods: List of method dictionaries.
        proto_file: Original proto file path.

    Returns:
        Generated implementation code.
    """
    method_impls = []
    for method in methods:
        method_impls.append(_METHOD_IMPL_TEMPLATE.format(
            method_name=method.get("name", "unknown"),
            request_type=_to_python_type(method.get("request_type", "Any")),
            response_type=_to_python_type(method.get("response_type", "Any")),
        ))

    all_method_impls = "".join(method_impls)

    return _IMPL_TEMPLATE.format(
        service_name=service_name,
        service_lower=service_name.lower(),
        proto_file=proto_file or "unknown",
        method_impls=all_method_impls,
    )


def generate_server_with_decorator(
    service_name: str,
    methods: list[dict],
    proto_file: str = "",
) -> str:
    """Generate server code with @rpc_service decorator.

    Args:
        service_name: Name of the service.
        methods: List of method dictionaries.
        proto_file: Original proto file path.

    Returns:
        Generated Python code with decorator.
    """
    method_impls = []
    for method in methods:
        method_impls.append(_METHOD_IMPL_TEMPLATE.format(
            method_name=method.get("name", "unknown"),
            request_type=_to_python_type(method.get("request_type", "Any")),
            response_type=_to_python_type(method.get("response_type", "Any")),
        ))

    all_method_impls = "".join(method_impls)

    return _DECORATOR_TEMPLATE.format(
        service_name=service_name,
        method_impls=all_method_impls,
    )


class ServerGenerator:
    """Server code generator with more configuration options."""

    def __init__(
        self,
        with_abstract: bool = True,
        with_impl: bool = True,
        with_decorator: bool = True,
    ) -> None:
        """Initialize the generator.

        Args:
            with_abstract: Generate abstract base class.
            with_impl: Generate implementation stubs.
            with_decorator: Use @rpc_service decorator.
        """
        self.with_abstract = with_abstract
        self.with_impl = with_impl
        self.with_decorator = with_decorator

    def generate_abstract(self, service, proto_file: str = "") -> str:
        """Generate abstract base class.

        Args:
            service: ProtoService instance.
            proto_file: Original proto file path.

        Returns:
            Generated abstract class code.
        """
        methods = [
            {
                "name": rpc.name,
                "request_type": rpc.request_type,
                "response_type": rpc.response_type,
            }
            for rpc in service.rpcs
        ]

        return generate_server_code(
            service_name=service.name,
            methods=methods,
            proto_file=proto_file,
            generate_impl=False,
        )

    def generate_impl(self, service, proto_file: str = "") -> str:
        """Generate implementation class with stubs.

        Args:
            service: ProtoService instance.
            proto_file: Original proto file path.

        Returns:
            Generated implementation class code.
        """
        methods = [
            {
                "name": rpc.name,
                "request_type": rpc.request_type,
                "response_type": rpc.response_type,
            }
            for rpc in service.rpcs
        ]

        return generate_server_code(
            service_name=service.name,
            methods=methods,
            proto_file=proto_file,
            generate_impl=True,
        )

    def generate_with_decorator(self, service, proto_file: str = "") -> str:
        """Generate class with @rpc_service decorator.

        Args:
            service: ProtoService instance.
            proto_file: Original proto file path.

        Returns:
            Generated decorated class code.
        """
        methods = [
            {
                "name": rpc.name,
                "request_type": rpc.request_type,
                "response_type": rpc.response_type,
            }
            for rpc in service.rpcs
        ]

        return generate_server_with_decorator(
            service_name=service.name,
            methods=methods,
            proto_file=proto_file,
        )


def _to_python_type(proto_type: str) -> str:
    """Convert Proto type to Python type annotation.

    Args:
        proto_type: Proto type name.

    Returns:
        Python type annotation string.
    """
    # Primitive type mappings
    primitives = {
        "double": "float",
        "float": "float",
        "int32": "int",
        "int64": "int",
        "uint32": "int",
        "uint64": "int",
        "sint32": "int",
        "sint64": "int",
        "fixed32": "int",
        "fixed64": "int",
        "sfixed32": "int",
        "sfixed64": "int",
        "bool": "bool",
        "string": "str",
        "bytes": "bytes",
    }

    if proto_type in primitives:
        return primitives[proto_type]

    # Check for repeated (list)
    if proto_type.startswith("repeated "):
        base_type = proto_type[9:].strip()
        return f"list[{_to_python_type(base_type)}]"

    # Check for map (dict)
    if proto_type.startswith("map<") and proto_type.endswith(">"):
        inner = proto_type[4:-1].strip()
        if "," in inner:
            key_type, value_type = inner.split(",", 1)
            return f"dict[{_to_python_type(key_type.strip())}, {_to_python_type(value_type.strip())}]"

    # Default to Any for message types
    return proto_type
