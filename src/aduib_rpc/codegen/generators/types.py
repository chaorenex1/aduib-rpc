"""Type conversion code generator for aduib_rpc.

Generates Python dataclasses and Pydantic models from Proto message definitions.
"""
from __future__ import annotations

from typing import Final

__all__ = ["generate_type_code", "TypeGenerator"]

# Pydantic model template
_PYDANTIC_TEMPLATE: Final = '''"""Autogenerated types from {proto_file}.

DO NOT EDIT - This file was generated by aduib-codegen.
"""

from __future__ import annotations

from typing import Any
from pydantic import BaseModel, Field

{type_definitions}
'''

# Dataclass template
_DATACLASS_TEMPLATE: Final = '''"""Autogenerated types from {proto_file}.

DO NOT EDIT - This file was generated by aduib-codegen.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any

{type_definitions}
'''

# Enum template
_ENUM_TEMPLATE: Final = '''
class {enum_name}(str):
    """Enum for {enum_name}."""
{enum_values}
'''

# Pydantic model class template
_PYDANTIC_MODEL_TEMPLATE: Final = '''
class {class_name}(BaseModel):
    """Pydantic model for {class_name}."""
{fields}
'''

# Dataclass template
_DATACLASS_CLASS_TEMPLATE: Final = '''
@dataclass
class {class_name}:
    """Dataclass for {class_name}."""
{fields}
'''

# Field template for Pydantic
_PYDANTIC_FIELD_TEMPLATE: Final = '    {field_name}: {field_type} = Field(default={default}, description="{description}")'

# Field template for dataclass
_DATACLASS_FIELD_TEMPLATE: Final = '    {field_name}: {field_type} = {default}'


def generate_type_code(
    messages: list[dict],
    enums: list[dict] | None = None,
    proto_file: str = "",
    use_pydantic: bool = True,
) -> str:
    """Generate type code for messages and enums.

    Args:
        messages: List of message dictionaries with 'name' and 'fields'.
        enums: Optional list of enum dictionaries with 'name' and 'values'.
        proto_file: Original proto file path.
        use_pydantic: Generate Pydantic models (otherwise dataclasses).

    Returns:
        Generated Python code as string.
    """
    enums = enums or []

    if use_pydantic:
        return _generate_pydantic_types(messages, enums, proto_file)
    else:
        return _generate_dataclass_types(messages, enums, proto_file)


def _generate_pydantic_types(
    messages: list[dict],
    enums: list[dict],
    proto_file: str,
) -> str:
    """Generate Pydantic models.

    Args:
        messages: List of message definitions.
        enums: List of enum definitions.
        proto_file: Original proto file path.

    Returns:
        Generated Pydantic model code.
    """
    type_definitions = []

    # Generate enums first
    for enum in enums:
        type_definitions.append(_generate_enum(enum))

    # Generate message models
    for message in messages:
        type_definitions.append(_generate_pydantic_model(message))

    return _PYDANTIC_TEMPLATE.format(
        proto_file=proto_file or "unknown",
        type_definitions="".join(type_definitions),
    )


def _generate_dataclass_types(
    messages: list[dict],
    enums: list[dict],
    proto_file: str,
) -> str:
    """Generate dataclasses.

    Args:
        messages: List of message definitions.
        enums: List of enum definitions.
        proto_file: Original proto file path.

    Returns:
        Generated dataclass code.
    """
    type_definitions = []

    # Generate enums first
    for enum in enums:
        type_definitions.append(_generate_enum(enum))

    # Generate message dataclasses
    for message in messages:
        type_definitions.append(_generate_dataclass(message))

    return _DATACLASS_TEMPLATE.format(
        proto_file=proto_file or "unknown",
        type_definitions="".join(type_definitions),
    )


def _generate_enum(enum: dict) -> str:
    """Generate enum class code.

    Args:
        enum: Enum dictionary with 'name' and 'values'.

    Returns:
        Generated enum code.
    """
    enum_name = enum.get("name", "UnknownEnum")
    values = enum.get("values", [])

    enum_values = []
    for value in values:
        enum_values.append(f'    {value.get("name", "UNKNOWN")} = "{value.get("name", "UNKNOWN")}"')

    return _ENUM_TEMPLATE.format(
        enum_name=enum_name,
        enum_values="\n".join(enum_values),
    )


def _generate_pydantic_model(message: dict) -> str:
    """Generate Pydantic model code.

    Args:
        message: Message dictionary with 'name' and 'fields'.

    Returns:
        Generated Pydantic model code.
    """
    class_name = message.get("name", "UnknownType")
    fields = message.get("fields", [])

    field_defs = []
    for field in fields:
        field_defs.append(_generate_pydantic_field(field))

    return _PYDANTIC_MODEL_TEMPLATE.format(
        class_name=class_name,
        fields="\n".join(field_defs) if field_defs else "    pass",
    )


def _generate_pydantic_field(field: dict) -> str:
    """Generate Pydantic field code.

    Args:
        field: Field dictionary with 'name', 'type', and optional 'default'.

    Returns:
        Generated field code.
    """
    field_name = field.get("name", "unknown")
    field_type = _to_python_type(field.get("type", "Any"))
    default = field.get("default", "None")
    description = field.get("description", "")

    return _PYDANTIC_FIELD_TEMPLATE.format(
        field_name=field_name,
        field_type=field_type,
        default=default,
        description=description,
    )


def _generate_dataclass(message: dict) -> str:
    """Generate dataclass code.

    Args:
        message: Message dictionary with 'name' and 'fields'.

    Returns:
        Generated dataclass code.
    """
    class_name = message.get("name", "UnknownType")
    fields = message.get("fields", [])

    field_defs = []
    for field in fields:
        field_defs.append(_generate_dataclass_field(field))

    return _DATACLASS_CLASS_TEMPLATE.format(
        class_name=class_name,
        fields="\n".join(field_defs) if field_defs else "    pass",
    )


def _generate_dataclass_field(field: dict) -> str:
    """Generate dataclass field code.

    Args:
        field: Field dictionary with 'name', 'type', and optional 'default'.

    Returns:
        Generated field code.
    """
    field_name = field.get("name", "unknown")
    field_type = _to_python_type(field.get("type", "Any"))
    default = field.get("default", "None")

    # Handle default value syntax
    if default == "None":
        default_str = "None"
    elif default == "":
        default_str = '""'
    elif default == "[]":
        default_str = "factory=list"
    elif default == "{}":
        default_str = "factory=dict"
    else:
        default_str = repr(default)

    return _DATACLASS_FIELD_TEMPLATE.format(
        field_name=field_name,
        field_type=field_type,
        default=default_str,
    )


class TypeGenerator:
    """Type code generator with more configuration options."""

    def __init__(
        self,
        use_pydantic: bool = True,
        with_validation: bool = True,
        with_serialization: bool = True,
    ) -> None:
        """Initialize the generator.

        Args:
            use_pydantic: Generate Pydantic models (otherwise dataclasses).
            with_validation: Add validation methods.
            with_serialization: Add serialization methods.
        """
        self.use_pydantic = use_pydantic
        self.with_validation = with_validation
        self.with_serialization = with_serialization

    def generate_from_proto_file(self, proto_file, output_path: str | None = None) -> str:
        """Generate types from a ProtoFile.

        Args:
            proto_file: ProtoFile instance.
            output_path: Optional path to write the generated file.

        Returns:
            Generated code.
        """
        messages = [
            {
                "name": msg.name,
                "fields": [
                    {
                        "name": f.name,
                        "type": f.type_name,
                        "default": "None" if f.label != "required" else '""',
                    }
                    for f in msg.fields
                ],
            }
            for msg in proto_file.messages
        ]

        enums = [
            {
                "name": enum.name,
                "values": [
                    {"name": v.name, "number": v.number}
                    for v in enum.values
                ],
            }
            for enum in proto_file.enums
        ]

        code = generate_type_code(
            messages=messages,
            enums=enums,
            proto_file=str(proto_file.path),
            use_pydantic=self.use_pydantic,
        )

        if output_path:
            from pathlib import Path
            Path(output_path).write_text(code, encoding="utf-8")

        return code


def _to_python_type(proto_type: str) -> str:
    """Convert Proto type to Python type annotation.

    Args:
        proto_type: Proto type name.

    Returns:
        Python type annotation string.
    """
    # Primitive type mappings
    primitives = {
        "double": "float",
        "float": "float",
        "int32": "int",
        "int64": "int",
        "uint32": "int",
        "uint64": "int",
        "sint32": "int",
        "sint64": "int",
        "fixed32": "int",
        "fixed64": "int",
        "sfixed32": "int",
        "sfixed64": "int",
        "bool": "bool",
        "string": "str",
        "bytes": "bytes",
    }

    if proto_type in primitives:
        return primitives[proto_type]

    # Check for repeated (list)
    if proto_type.startswith("repeated "):
        base_type = proto_type[9:].strip()
        return f"list[{_to_python_type(base_type)}]"

    # Check for map (dict)
    if proto_type.startswith("map<") and proto_type.endswith(">"):
        inner = proto_type[4:-1].strip()
        if "," in inner:
            key_type, value_type = inner.split(",", 1)
            return f"dict[{_to_python_type(key_type.strip())}, {_to_python_type(value_type.strip())}]"

    # Default to Any for message types
    return proto_type
